本文探讨的是为什么Lisp语言不再被广泛使用的。

很久以前，这种语言站在计算机科学研究的前沿，特别是人工智能的研究方面。现在，它很少被用到，这一切并不是因为古老,类似古老的语言却被广泛应用.

其他类似的古老的语言有 FORTRAN, COBOL, LISP, BASIC, 和ALGOL 家族,这些语言的唯一不同之处在于,他们为谁设计,FORTRAN是为科学家和工程师设计的,他们在计算机上编程的目的是是为了解决问题.COBOL是为了商业设计的,最好的体现在于让商人们可以利用电脑时代.LISP是了计算机科学研究设计的,最突出的体现在计算机基本原理研究.BASIC是为初学者设计的.最后,ALGOL语言是有计算机程序员修改，演变成其他流行的语言，如C，Pascal和Java的一个庞大的家族。

上面提到的某些语言已经不像当初那么流行了。我们在这里可以把它们称作“失败”。问题是它们为什么失败？第一站出来的是COBOL. 很不幸，它以面向商业人员的很好的可读性就是它的失败点。商业人员发现，他们可以雇佣程序员去管理他们的系统。程序员自然会偏向于为他们设计的语言，而不是他们的老板。所以随着时间推移，越来越多的商业功能都使用例如VB, C, C++ 和JAVA实现了。现在，只有很少一部分软件仍通过COBOL语言编写。

BASIC却有不同的命运。他是为入门人员设计的。那些在微机上学习编程，他们会使用内置的BASIC语言作为起点。随着时间推移，微机被运行微软操作系统的个人电脑，或者MacOS的苹果电脑所代替。这种语言逐渐被VB所取代。虽然他是面向初级程序员，它有一段时间代替了COBOL。为什么要耗费这么多的资源在昂贵的编译器上，而便宜的解释器在我们的电脑上已经存在？最近，微软以迁移到.NET框架上，让VB跟在后面。它的替代者， C#就是ALGOL家族中的一员，跟Java相近。

这些年FORTRAN的使用起起伏伏。在某一阶段，差不多所有科学方面的代码是用它来写的。它的优点是这门语言中没有指针，并且不允许存在递归。这意味着所有数据的引用位置都可以在编译时确定。FORTRAN编译器利用这些额外的信息使程序运行格外地迅速。不幸的是，随着时间的推移，固定大小的数组这种数据结构变得过时了。现在，科学要处理任意形状的风格，甚至表述更为复杂的真实世界。这需要在语言中额外地加入指针。这些情况发生的时间段里，FORTRAN逐渐走向没落。现在，它被转移到高性能计算工作，其中新的并行矩阵和矢量运算最近添加到这门语言中，仍然使它拥有性能优势。

ALGOL语言家族取得了成功。其原因是，这些语言是由程序员为程序员写的。随着时间的推移，这些与系统和应用相关的语言成为了现在最常用的语言。它的优点是越多地程序员使用，这门语言就能得到更多地改进，并且越来越多地程序是用它们来写就的。这提供了一个良性循环，更多的程序员们又被聘请在己编写的程序上工作。这是一个网络效应的例子。一个系统的“价值”是它的用户数目的平方，在于以此速率增长的用户之间的交互作用。

那么为什么Lisp语言家族会站在失败者一边呢？有些人认为是语法的错。Lisp因为它的括号而臭名昭著。我并不认为是这个理由。许多用户说良好的格式可以让他们跟上这些括号。同时，Lisp语言被发明不久后，有一个叫“super-bracket”的语法可以让人快速表示出任意数量的回括号")"。这个特性在今天已经很少有人使用了。最后，优秀的编辑器解决了大多数的语法问题。

另一些人经常抱怨Lisp是一门函数式语言。这是失败的理由吗？自然，跟早期的语言相比，只有Lisp算是函数式的。但事实上，我认为没有这么简单。Lisp也有命令式语言的特性，ALGOL系列语言也可以被当作一门纯正的函数式语言来用。 如果有人想选择一种特定的编程范式来写代码，一些特定的语言可以让这个选择更容易的实现。然而，现代语言已经足够灵活，它们能支持多种编程范式，近乎完全命令式的Lisp没有理由不存在。

或许lisp的问题在于他使用了垃圾回收？在那个时候，只有lisp作为计算机语言采用了这个特性。诚然，垃圾回收会占用大量的计算资源，而早期计算机在该方面的不足足以组织lisp大展拳脚了。但是，我认为这仍然不是主要的原因。lisp是用来写那些复杂度相当高的程序的，而这些程序在事实上都必须带有一个垃圾回收模块，如果你用其他的语言来写……大概很难比lisp实现的要好吧？众所周知的事实是，任何一个如此复杂的程序，如果用其他语言写的话都不可避免的戴上一个比lisp垃圾回收臃肿不少的功能模块……

lisp的失败，恰恰是因为他太成功，这让他的目标变得模糊。lisp相对与早期的语言实在是非常灵活，灵活到足以改变自身形式以适应需求。对于其他的语言来说，如果想要完成一个庞大的任务，就需要把这个任务打碎成一小块一小块的然后完成。如果是一个更大的呢？甚至连编译都需要分步完成了。但是lisp不是这样的，由于他强大的能力，程序员可以将lisp改造成特定领域的专门工具——顺手的工具将顺手的解决问题——任务轻松完成了。由于语言的正交性（译者注：这里可能应该理解为“自洽”），我们改造过的lisp仍然可以使用原有的编译器，解释器运行。

那么建立特定领域的语言来作为一个问题的解决方案，它会出现什么问题呢？结果是它非常高效。然而，这种做法会使语言分化。这导致许多子语言都略有不同。这是Lisp代码对其他人而言可读性差的真正原因。在其他语言中，相对来说比较简单就能臆测出一段给定代码的作用。有着超强的表达力的Lisp，由于一个给定的符号(symbol)可能是一个变量，函数或操作，需要阅读大量代码才能找出它。

Lisp失败的原因是因为它的碎片化，并且它的碎片化是因为其语言天性与特定领域方案的风格造成的。而网络效应则恰恰相反。越来越少的程序员使用相同的方言，因此它相对与ALGOL语言家族的总价值下降。

如果有人现在设计一种语言，该如何避免这种问题呢？如果语言的表达性是我们的目标，那么它必须以某种方式加以调整。这门语言必须要有特意的限制，来保证所编写代码的可读性。Python是一门成功的语言，它已经做到了这些，其中某些限制是硬编码的，而另一些则是以约定成俗的方式存在。

不幸的是,这么久过去了并且发明了这么多Lisp的变种语言，在其之上建立的其它新语言大概并不是所要的答案。根本不会有足够多的用户使它与众不同。也许解决的办法是，慢慢加入类似Lisp的语言功能到ALGOL语言家族中。幸运的是，这似乎是正在发生的事。新的语言（C＃，D，Python等）趋向于拥有垃圾回收机制。他们也往往比旧的语言更具正交性。在未来，最终会有行为很像Lisp的一种流行语言。

https://locklessinc.com/articles/why_lisp_failed/